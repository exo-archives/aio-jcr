/**
 * Copyright 2001-2003 The eXo Platform SARL         All rights reserved.  *
 * Please look at license.txt in info directory for more license detail.   *
 */

package org.exoplatform.services.jcr.impl.storage.cache;

import java.lang.ref.PhantomReference;
import java.lang.ref.Reference;
import java.lang.ref.SoftReference;
import java.lang.ref.WeakReference;
import java.util.Iterator;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Set;

import javax.jcr.RepositoryException;

import org.apache.commons.logging.Log;
import org.exoplatform.services.cache.CacheService;
import org.exoplatform.services.cache.ExoCache;
import org.exoplatform.services.jcr.config.CacheEntry;
import org.exoplatform.services.jcr.config.WorkspaceEntry;
import org.exoplatform.services.jcr.datamodel.IllegalPathException;
import org.exoplatform.services.jcr.datamodel.InternalQPath;
import org.exoplatform.services.jcr.datamodel.ItemData;
import org.exoplatform.services.jcr.datamodel.NodeData;
import org.exoplatform.services.jcr.impl.core.ItemChangeState;
import org.exoplatform.services.jcr.impl.core.ItemImpl;
import org.exoplatform.services.jcr.impl.core.ItemState;
import org.exoplatform.services.jcr.impl.core.SessionImpl;
import org.exoplatform.services.jcr.impl.dataflow.ItemsPersistenceListener;
import org.exoplatform.services.log.ExoLogger;

/**
 * Created by The eXo Platform SARL .
 * 
 * @author <a href="mailto:gennady.azarenkov@exoplatform.com">Gennady Azarenkov
 *         </a>
 * @version $Id: WorkspaceCache.java.1 12841 2007-02-16 08:58:38Z peterit $
 */

public class WorkspaceCache implements ItemsPersistenceListener {

  protected static Log log = ExoLogger.getLogger("jcr.WorkspaceCache");

  private ExoCache cache;

  private String   name;

  private boolean  enabled;

  public WorkspaceCache(CacheService cacheService, WorkspaceEntry wsConfig)
      throws Exception {

    name = "jcr." + wsConfig.getUniqueName();
    cache = cacheService.getCacheInstance(name);

    CacheEntry cacheConfig = wsConfig.getCache();
    if (cacheConfig != null) {
      enabled = cacheConfig.isEnabled();
      cache.setMaxSize(Integer.parseInt(cacheConfig.getParameterValue("maxSize")));
      cache.setLiveTime(Long.parseLong(cacheConfig.getParameterValue("liveTime")));
    } else {
      enabled = true;
    }
  }

  /**
   * @param name
   * @return
   * @throws Exception
   */
  public ItemData get(InternalQPath path) {

    if (!enabled)
      return null;

    try {
      // log.debug("Cache get by path >> "+path.getAsString()+" uuid "+);
      String pathString = path.getAsString();
      ItemData data = (ItemData) cache.get(pathString);
      if (data != null && data instanceof NodeData)
        log.debug("Cache get by path >> " + pathString + " found uuid: " + data.getUUID()
            + " primaryType: " + ((NodeData) data).getPrimaryTypeName().getAsString());

      return data;
    } catch (Exception e) {
      return null;
    }
  }

  private void showCache() {
    System.err.println("============ showCache");
    try {
      if (cache instanceof LinkedHashMap) {
        LinkedHashMap _c = (LinkedHashMap) cache;
        Set allObject = _c.keySet();
        if (allObject == null)
          return;
        for (Iterator iter = allObject.iterator(); iter.hasNext();) {
          Object key = iter.next();
          if (key == null)
            continue;
          Object o = _c.get(key);
          if (o instanceof Reference) {
            Reference ref = (Reference) o;
            Object refObject = ref.get();
            String cacheItem = "===== REF("+
            (ref instanceof SoftReference ? "SOFT" : 
              ((ref instanceof PhantomReference ? "PHANTOM" : 
                (ref instanceof WeakReference ? "WEEK" : "")))) + "): ";
            if (refObject instanceof ItemData) {
              ItemData itemData = (ItemData) refObject;
              cacheItem +=  
                  itemData.getQPath().getAsString()
                  + "; UUID:" + itemData.getUUID()                  
                  + "; PersistedVersion:" + itemData.getPersistedVersion()
                  + "; " + itemData;
//              if (refObject instanceof NodeData) {
//                NodeData nodeData = (NodeData) refObject;
//                cacheItem += "; PrimaryType:" + nodeData.getPrimaryTypeName().getAsString();
//              }
            } else {
              cacheItem = "===== REF: " + refObject;
            }
            System.err.println(cacheItem);
          }
        }
      } else {
        System.err.println("============ cached map not supported");
      }
    } catch (Exception e) {
      System.err.println("============ cached item exception: " + e);
    }
  }

  public ItemData get(String uuid) {
    if (!enabled)
      return null;

    try {

      ItemData data = (ItemData) cache.get(uuid);
      // System.out.println("From cache name "+this+" "+name);
      // if (data != null && data instanceof NodeData)
      // System.out.println("Cache get by uuid >> " + uuid + " found path: "
      // + data.getQPath().getAsString() + " primaryType: "
      // + ((NodeData) data).getPrimaryTypeName().getAsString());

      return data;
    } catch (Exception e) {
      return null;
    }
  }

  /**
   * Called by read operations
   * 
   * @param data
   */
  public void put(ItemData data) {
    try {
      if (enabled && data != null /* && (data instanceof PropertyData) */) {
        
//        if (data.getQPath().getAsString().indexOf("testroot")>=0) {
//          System.err.println("==== before; path: " + data.getQPath().getAsString());
//          showCache();
//        }
        
        cache.put(data.getQPath().getAsString(), data);

        cache.put(data.getUUID(), data);
        // have to refresh cached parent somewhere if use for r/w operations!

        // if (data.isNode())
        // log.debug("Cache " + name + " put >> "
        // + data.getQPath().getAsString() + " uuid: " + data.getUUID()
        // + " child node " + ((NodeData) data).getChildNodes());
        
//        if (data.getQPath().getAsString().indexOf("testroot")>=0) {
//          System.err.println("==== after; path: " + data.getQPath().getAsString());
//          showCache();
//        }
      }
    } catch (Exception e) {
    }
  }

  public void clear() throws RepositoryException {
    try {
      log.debug("Cache is about to clear >> " + cache.getCacheSize());
      cache.clearCache();
      log.debug("Cache cleared >> " + cache.getCacheSize());
    } catch (Exception e) {
      e.printStackTrace();
      throw new RepositoryException("Exception in clear Cache " + e);
    }
  }

  public boolean isEnabled() {
    return enabled;
  }

  public void setEnabled(boolean enabled) {
    this.enabled = enabled;
  }

  public void setMaxSize(int maxSize) {
    this.cache.setMaxSize(maxSize);
  }

  public void setLiveTime(long liveTime) {
    this.cache.setLiveTime(liveTime);
  }

  public void removeItem(ItemImpl item) throws RepositoryException {
    remove(item.getActualItemData());
  }
  
  // --------------------- ItemsPersistenceListener --------------
  public synchronized void onBatchSaveItems(List itemStates, SessionImpl session) {
  }

  public synchronized void onSaveItems(List itemStates, SessionImpl session) {
    for (Iterator i = itemStates.iterator(); i.hasNext();) {
      ItemState state = (ItemState) i.next();
      ItemData data = state.getData();

      try {
        if (state.getState() == ItemChangeState.ADDED) {
          addTree(data);
        } else if (state.getState() == ItemChangeState.DELETED
            || state.getState() == ItemChangeState.AUTO_DELETED) {
          remove(data);
        } else if (state.getState() == ItemChangeState.UPDATED) {
          update(data);
        }
      } catch (RepositoryException e) {
        e.printStackTrace();
      }
    }
  }

  // ---------------------------------------------------

  /**
   * Called by delete
   * 
   * @param data
   */
  private void remove(ItemData data) throws RepositoryException {
    throw new RepositoryException("Do not use this anymore!");

/*
    if (!enabled)
      return;

    try {
      log.debug("Cache remove item and descendants >> " + data.getQPath().getAsString());

      // System.err.println("====== geting item: " +
      // data.getQPath().getAsString());

      ItemData item = this.get(data.getQPath());

      if (item != null && item instanceof NodeData) {

        // System.err.println("====== have an item: " +
        // item.getQPath().getAsString());

        NodeData node = (NodeData) item;
        Iterator props = node.getChildProperties().iterator();

        while (props.hasNext()) {
          String propName = ((ItemData) props.next()).getQPath().getAsString();
          // System.err.println("====== remove prop: " + propName);
          cache.remove(propName);
        }

        Iterator nodes = node.getChildNodes().iterator();
        while (nodes.hasNext()) {
          String childName = ((ItemData) nodes.next()).getQPath().getAsString();
          // System.err.println("====== remove child: " + childName);
          cache.remove(childName);
        }
      }

      // System.err.println("====== removing: " +
      // data.getQPath().getAsString());
      cache.remove(data.getQPath().getAsString());

      // System.err.println("====== removing by UUID: " + data.getUUID());
      cache.remove(data.getUUID());
      // System.out.println("Cache remove >> "+loc.getPath());

      // if (data.getQPath().getAsString().indexOf("target") >= 0) {
      // showCache();
      // }

    } catch (Exception e) {
      e.printStackTrace();
      throw new RepositoryException("Exception in remove Cache " + e);
    }
*/    
  }

  /**
   * Called by add operation
   * 
   * @param data
   */

  private void add(ItemData data) throws RepositoryException {

    if (enabled) {
      put(data);

      NodeData parent;
      try {
        parent = (NodeData) get(data.getQPath().makeParentPath().getAsString());
      } catch (IllegalPathException e) {
        throw new RepositoryException(e);
      }
      if (parent != null) {
        log.debug("Cache " + name + " remove parent >> " + parent.getQPath().getAsString());
        remove(parent);
      }
    }
  }

  private void addTree(ItemData data) throws RepositoryException {
    
    throw new RepositoryException("Do not use this anymore!");
/*
    add(data);
    if (data.isNode()) {
      NodeData node = (NodeData) data;
      List props = node.getChildProperties();
      if (props != null)
        for (int i = 0; i < props.size(); i++)
          addTree((PropertyData) props.get(i));
      List nodes = node.getChildNodes();
      if (nodes != null)
        for (int i = 0; i < nodes.size(); i++)
          addTree((NodeData) nodes.get(i));
    }
*/
  }

  private void update(ItemData data) {
    if (enabled) {
      put(data);
    }
  }

}
