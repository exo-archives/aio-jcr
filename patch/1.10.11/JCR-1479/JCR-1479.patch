Index: component/core/src/main/java/org/exoplatform/services/jcr/impl/xml/importing/BaseXmlImporter.java
===================================================================
--- component/core/src/main/java/org/exoplatform/services/jcr/impl/xml/importing/BaseXmlImporter.java	(revision 64029)
+++ component/core/src/main/java/org/exoplatform/services/jcr/impl/xml/importing/BaseXmlImporter.java	(working copy)
@@ -496,7 +496,7 @@
     // update parentIdentifer
     for (ItemState state : changesLog.getAllStates()) {
       ItemData data = state.getData();
-      if (data.getParentIdentifier().equals(oldIdentifer)) {
+      if (data.getParentIdentifier() != null && data.getParentIdentifier().equals(oldIdentifer)) {
         ((ImportItemData) data).setParentIdentifer(identifier);
         if (reloadSNS)
           ((ImportItemData) data).setQPath(QPath.makeChildPath(newPath, data.getQPath().getName()));
Index: component/core/src/test/java/org/exoplatform/services/jcr/api/importing/TestImportReferenceable.java
===================================================================
--- component/core/src/test/java/org/exoplatform/services/jcr/api/importing/TestImportReferenceable.java	(revision 0)
+++ component/core/src/test/java/org/exoplatform/services/jcr/api/importing/TestImportReferenceable.java	(revision 0)
@@ -0,0 +1,136 @@
+/*
+ * Copyright (C) 2003-2010 eXo Platform SAS.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Affero General Public License
+ * as published by the Free Software Foundation; either version 3
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, see<http://www.gnu.org/licenses/>.
+ */
+package org.exoplatform.services.jcr.api.importing;
+
+import org.exoplatform.services.jcr.datamodel.NodeData;
+import org.exoplatform.services.jcr.impl.core.NodeImpl;
+import org.exoplatform.services.jcr.impl.core.SessionImpl;
+import org.exoplatform.services.jcr.impl.core.nodetype.NodeTypeManagerImpl;
+import org.exoplatform.services.jcr.impl.dataflow.session.TransactionableDataManager;
+import org.exoplatform.services.jcr.impl.xml.ExportImportFactory;
+import org.exoplatform.services.jcr.impl.xml.importing.ContentImporter;
+import org.exoplatform.services.jcr.impl.xml.importing.StreamImporter;
+
+import java.io.File;
+import java.io.FileInputStream;
+import java.io.FileOutputStream;
+import java.util.HashMap;
+import java.util.Map;
+
+import javax.jcr.ImportUUIDBehavior;
+import javax.jcr.Node;
+import javax.jcr.NodeIterator;
+import javax.jcr.Session;
+
+/**
+ * Created by The eXo Platform SAS Author : eXoPlatform exo@exoplatform.com
+ * 13.12.2010
+ */
+public class TestImportReferenceable extends AbstractCollisionTest {
+
+  public void tearDown() throws Exception {
+
+    // cleanup ws1
+    Session sysSession = repository.getSystemSession("ws1");
+    NodeIterator nit = sysSession.getRootNode().getNodes();
+    while (nit.hasNext()) {
+      nit.nextNode().remove();
+      sysSession.save();
+    }
+    // cleanup ws2
+    sysSession = repository.getSystemSession("ws2");
+    nit = sysSession.getRootNode().getNodes();
+    while (nit.hasNext()) {
+      nit.nextNode().remove();
+      sysSession.save();
+    }
+    super.tearDown();
+  }
+
+  /**
+   * Usecase: put a referenceable node into workspace export full workspace
+   * content import this data into another workspace There must not be
+   * NullPointerException.
+   * 
+   * @throws Exception
+   */
+  public void testJCR1479ExportImportWorkspaceWithReference() throws Exception {
+    // cleanup ws1 content
+    Session sysSession = repository.getSystemSession("ws1");
+    NodeIterator nit = sysSession.getRootNode().getNodes();
+    while (nit.hasNext()) {
+      nit.nextNode().remove();
+      sysSession.save();
+    }
+
+    File tempFile = File.createTempFile("testJCR1479", "suf");
+    FileOutputStream fout = null;
+    FileInputStream fin = null;
+    // take a ws1 session
+    SessionImpl sessWS1 = (SessionImpl) repository.login(credentials, "ws1");
+    try {
+
+      // make mix:referenceable node
+      Node n = sessWS1.getRootNode().addNode("testRefNode");
+      n.addMixin("mix:referenceable");
+      sessWS1.save();
+
+      fout = new FileOutputStream(tempFile);
+
+      sessWS1.exportWorkspaceSystemView(fout, false, false);
+      fout.close();
+
+      fin = new FileInputStream(tempFile);
+
+      Map<String, Object> context = new HashMap<String, Object>();
+      context.put(ContentImporter.RESPECT_PROPERTY_DEFINITIONS_CONSTRAINTS, true);
+
+      SessionImpl sessWS2 = (SessionImpl) repository.login(credentials, "ws2");
+      NodeData rootData = ((NodeData) ((NodeImpl) sessWS2.getRootNode()).getData());
+      TransactionableDataManager dataManager = sessWS2.getTransientNodesManager()
+                                                      .getTransactManager();
+      ExportImportFactory eiFactory = new ExportImportFactory();
+
+      StreamImporter importer = eiFactory.getWorkspaceImporter(rootData,
+                                                               ImportUUIDBehavior.IMPORT_UUID_COLLISION_THROW,
+                                                               dataManager,
+                                                               dataManager,
+                                                               (NodeTypeManagerImpl) repository.getNodeTypeManager(),
+                                                               sessWS2.getLocationFactory(),
+                                                               sessWS2.getValueFactory(),
+                                                               repository.getNamespaceRegistry(),
+                                                               sessWS2.getAccessManager(),
+                                                               sessWS2.getUserState(),
+                                                               context,
+                                                               repository,
+                                                               sessWS2.getWorkspace().getName());
+      importer.importStream(fin);
+      sessWS2.save();
+      sessWS2.logout();
+
+    } finally {
+      if (fout != null) {
+        fout.close();
+      }
+      if (fin != null) {
+        fin.close();
+      }
+      tempFile.delete();
+    }
+  }
+
+}
Index: component/ext/src/test/java/conf/standalone/test-configuration.xml
===================================================================
--- component/ext/src/test/java/conf/standalone/test-configuration.xml	(revision 64029)
+++ component/ext/src/test/java/conf/standalone/test-configuration.xml	(working copy)
@@ -1194,6 +1194,34 @@
         </properties-param>
       </init-params>
     </component-plugin>
+     <component-plugin>
+      <name>bind.datasource</name>
+      <set-method>addPlugin</set-method>
+      <type>org.exoplatform.services.naming.BindReferencePlugin</type>
+      <init-params>
+        <value-param>
+          <name>bind-name</name>
+          <value>jdbcjcr19</value>
+        </value-param>
+        <value-param>
+          <name>class-name</name>
+          <value>javax.sql.DataSource</value>
+        </value-param>
+        <value-param>
+          <name>factory</name>
+          <value>org.apache.commons.dbcp.BasicDataSourceFactory</value>
+        </value-param>
+        <properties-param>
+          <name>ref-addresses</name>
+          <description>ref-addresses</description>
+          <property name="driverClassName" value="org.hsqldb.jdbcDriver" />
+          <property name="url" value="jdbc:hsqldb:file:target/temp/data/jcr19" />
+          <property name="username" value="sa" />
+          <property name="password" value="" />
+        </properties-param>
+      </init-params>
+    </component-plugin>
+
     <!-- Resource configuration for UserTransaction
     use JOTM
     -->
Index: component/ext/src/test/java/org/exoplatform/services/jcr/ext/backup/TestBackupManager.java
===================================================================
--- component/ext/src/test/java/org/exoplatform/services/jcr/ext/backup/TestBackupManager.java	(revision 64029)
+++ component/ext/src/test/java/org/exoplatform/services/jcr/ext/backup/TestBackupManager.java	(working copy)
@@ -99,6 +99,80 @@
       fail("There are no backup files in " + backDir.getAbsolutePath());
   }
 
+  public void testJCR1479FullBackupRestore() throws Exception {
+
+    SessionImpl sessWS1 = (SessionImpl)repository.login(credentials, "ws1");
+
+    Node n = sessWS1.getRootNode().addNode("testRefNode");
+    n.addMixin("mix:referenceable");
+    sessWS1.save();
+
+    try {
+      // backup
+      File backDir = new File("target/backup/ws1jcr1479");
+      backDir.mkdirs();
+
+      BackupConfig config = new BackupConfig();
+      config.setRepository(repository.getName());
+      config.setWorkspace("ws1");
+      config.setBuckupType(BackupManager.FULL_BACKUP_ONLY);
+
+      config.setBackupDir(backDir);
+
+      backup.startBackup(config);
+
+      BackupChain bch = backup.findBackup(repository.getName(), "ws1");
+
+      // wait till full backup will be stopped
+      while (bch.getFullBackupState() != BackupJob.FINISHED) {
+        Thread.yield();
+        Thread.sleep(50);
+      }
+
+      // stop fullBackup
+
+      if (bch != null)
+        backup.stopBackup(bch);
+      else
+        fail("Can't get fullBackup chain");
+
+      // restore
+      RepositoryEntry re = (RepositoryEntry) ws1Session.getContainer()
+                                                       .getComponentInstanceOfType(RepositoryEntry.class);
+      WorkspaceEntry ws1back = makeWorkspaceEntry("ws1backjcr1479", "jdbcjcr19");
+
+      repository.configWorkspace(ws1back);
+
+      // BackupChainLog bchLog = new BackupChainLog(backDir, rconfig);
+      File backLog = new File(bch.getLogFilePath());
+      if (backLog.exists()) {
+        BackupChainLog bchLog = new BackupChainLog(backLog);
+
+        backup.restore(bchLog, re, ws1back);
+
+        // check
+        SessionImpl back1 = null;
+        try {
+          back1 = (SessionImpl) repository.login(credentials, "ws1back");
+          Node ws1backTestRoot = back1.getRootNode().getNode("backupTest");
+          assertEquals("Restored content should be same",
+                       "property-5",
+                       ws1backTestRoot.getNode("node_5").getProperty("exo:data").getString());
+        } catch (Exception e) {
+          e.printStackTrace();
+          fail(e.getMessage());
+        } finally {
+          if (back1 != null)
+            back1.logout();
+        }
+      } else
+        fail("There are no backup files in " + backDir.getAbsolutePath());
+    } finally {
+      n.remove();
+      sessWS1.save();
+    }
+  }
+
   public void testIncrementalBackupRestore() throws Exception {
     // full backup & incremental
     File backDir = new File("target/backup/ws1.incr");
