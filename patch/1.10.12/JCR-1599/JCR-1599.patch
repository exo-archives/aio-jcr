Index: component/core/src/main/java/org/exoplatform/services/jcr/dataflow/ItemState.java
===================================================================
--- component/core/src/main/java/org/exoplatform/services/jcr/dataflow/ItemState.java	(revision 68057)
+++ component/core/src/main/java/org/exoplatform/services/jcr/dataflow/ItemState.java	(working copy)
@@ -20,10 +20,11 @@
 import java.io.IOException;
 import java.io.ObjectInput;
 import java.io.ObjectOutput;
-
 import org.apache.commons.logging.Log;
+import org.exoplatform.services.jcr.datamodel.IllegalPathException;
 import org.exoplatform.services.jcr.datamodel.ItemData;
 import org.exoplatform.services.jcr.datamodel.QPath;
+import org.exoplatform.services.jcr.impl.Constants;
 import org.exoplatform.services.log.ExoLogger;
 
 /**
@@ -51,6 +52,8 @@
 
   public static final int     RENAMED           = 32;
 
+  public static final int     PATH_CHANGED      = 64;
+
   /**
    * underlying item data
    */
@@ -66,7 +69,7 @@
   private transient boolean   internallyCreated = false;
 
   /**
-   * if storing of this state ahould cause event firing
+   * if storing of this state should cause event firing
    */
   protected transient boolean eventFire;
 
@@ -76,15 +79,18 @@
   private transient QPath     ancestorToSave;
 
   /**
+   * Storing old node path during Session.move() operation
+   */
+  private QPath               oldPath;
+
+  /**
    * The constructor
    * 
-   * @param data
-   *          underlying data
+   * @param data underlying data
    * @param state
-   * @param eventFire
-   *          - if the state cause some event firing
-   * @param ancestorToSave
-   *          - path of item which should be called in save (usually for session.move())
+   * @param eventFire - if the state cause some event firing
+   * @param ancestorToSave - path of item which should be called in save
+   *          (usually for session.move())
    */
   public ItemState(ItemData data, int state, boolean eventFire, QPath ancestorToSave) {
     this(data, state, eventFire, ancestorToSave, false, true);
@@ -128,7 +134,17 @@
     if (log.isDebugEnabled())
       log.debug(nameFromValue(state) + " " + data.getQPath().getAsString() + ",  "
           + data.getIdentifier());
+  }
 
+  public ItemState(ItemData data,
+                   int state,
+                   boolean eventFire,
+                   QPath ancestorToSave,
+                   boolean isInternalCreated,
+                   boolean isPersisted,
+                   QPath oldPath) {
+    this(data, state, eventFire, ancestorToSave, isInternalCreated, isPersisted);
+    this.oldPath = oldPath;
   }
 
   public boolean isPersisted() {
@@ -177,6 +193,10 @@
     return (state == RENAMED);
   }
 
+  public boolean isPathChanged() {
+    return (state == PATH_CHANGED);
+  }
+
   public boolean isEventFire() {
     return eventFire;
   }
@@ -197,6 +217,11 @@
     return ancestorToSave;
   }
 
+  public QPath getOldPath() {
+    return oldPath;
+  }
+
+  @Override
   public boolean equals(Object obj) {
     if (this == obj)
       return true;
@@ -298,6 +323,8 @@
       return "MIXIN_CHANGED";
     case RENAMED:
       return "RENAMED";
+    case PATH_CHANGED:
+      return "PATH_CHANGED";
     default:
       return "UNDEFINED STATE";
     }
@@ -315,6 +342,15 @@
     out.writeInt(state);
     out.writeBoolean(isPersisted);
     out.writeBoolean(eventFire);
+
+    if (oldPath == null) {
+      out.writeInt(-1);
+    } else {
+      byte[] buf = oldPath.getAsString().getBytes(Constants.DEFAULT_ENCODING);
+      out.writeInt(buf.length);
+      out.write(buf);
+    }
+
     out.writeObject(data);
   }
 
@@ -322,6 +358,21 @@
     state = in.readInt();
     isPersisted = in.readBoolean();
     eventFire = in.readBoolean();
+
+    int len = in.readInt();
+    if (len == -1) {
+      oldPath = null;
+    } else {
+      byte[] buf = new byte[len];
+      in.readFully(buf);
+
+      try {
+        oldPath = QPath.parse(new String(buf, Constants.DEFAULT_ENCODING));
+      } catch (IllegalPathException e) {
+        throw new IOException("Data corrupted: can not parse string into QPath");
+      }
+    }
+
     data = (ItemData) in.readObject();
   }
 
Index: component/core/src/main/java/org/exoplatform/services/jcr/dataflow/ItemDataTraversingVisitor.java
===================================================================
--- component/core/src/main/java/org/exoplatform/services/jcr/dataflow/ItemDataTraversingVisitor.java	(revision 68057)
+++ component/core/src/main/java/org/exoplatform/services/jcr/dataflow/ItemDataTraversingVisitor.java	(working copy)
@@ -33,6 +33,8 @@
    * Maximum level.
    */
   protected final int              maxLevel;
+  
+  public static final int          INFINITE_DEPTH = -1;
 
   /**
    * Current level.
@@ -57,7 +59,7 @@
    *          - ItemDataConsumer
    */
   public ItemDataTraversingVisitor(ItemDataConsumer dataManager) {
-    this.maxLevel = -1;
+    this.maxLevel = INFINITE_DEPTH;
     this.dataManager = dataManager;
   }
 
@@ -75,7 +77,7 @@
   public void visit(NodeData node) throws RepositoryException {
     try {
       entering(node, currentLevel);
-      if (maxLevel == -1 || currentLevel < maxLevel) {
+      if (maxLevel == INFINITE_DEPTH || currentLevel < maxLevel) {
         currentLevel++;
         for (PropertyData data : dataManager.getChildPropertiesData(node))
           data.accept(this);
Index: component/core/src/main/java/org/exoplatform/services/jcr/impl/core/SessionImpl.java
===================================================================
--- component/core/src/main/java/org/exoplatform/services/jcr/impl/core/SessionImpl.java	(revision 68057)
+++ component/core/src/main/java/org/exoplatform/services/jcr/impl/core/SessionImpl.java	(working copy)
@@ -82,6 +82,7 @@
 import org.exoplatform.services.jcr.impl.xml.exporting.BaseXmlExporter;
 import org.exoplatform.services.jcr.impl.xml.importing.ContentImporter;
 import org.exoplatform.services.jcr.impl.xml.importing.StreamImporter;
+import org.exoplatform.services.jcr.storage.WorkspaceDataContainer;
 import org.exoplatform.services.jcr.util.IdGenerator;
 import org.exoplatform.services.security.ConversationState;
 import org.exoplatform.services.security.Identity;
@@ -131,6 +132,8 @@
 
   private long                                 lastAccessTime;
 
+  private boolean                              triggerEventsForDescendentsOnRename;
+
   private final SessionRegistry                sessionRegistry;
 
   protected final SessionDataManager           dataManager;
@@ -178,7 +181,9 @@
 
     sessionRegistry.registerSession(this);
     this.lastAccessTime = System.currentTimeMillis();
-
+    this.triggerEventsForDescendentsOnRename = wsConfig.getContainer()
+                                                       .getParameterBoolean(WorkspaceDataContainer.TRIGGER_EVENTS_FOR_DESCENDENTS_ON_RENAME,
+                                                                            WorkspaceDataContainer.TRIGGER_EVENTS_FOR_DESCENDENTS_ON_RENAME_DEFAULT);
   }
 
   /*
@@ -705,7 +710,7 @@
                                                                              .getMemberships(),
                                                                     userState.getIdentity()
                                                                              .getRoles()));
-    return (Session) sessionFactory.createSession(newState);
+    return sessionFactory.createSession(newState);
 
   }
 
@@ -871,7 +876,10 @@
                                                                           .getInternalName(),
                                                               getWorkspace().getNodeTypeManager(),
                                                               getTransientNodesManager(),
-                                                              true);
+                                                              true,
+                                                              triggerEventsForDescendentsOnRename
+                                                                  || !srcNodePath.makeParentPath()
+                                                                                 .equals(destNodePath.makeParentPath()));
 
     getTransientNodesManager().rename((NodeData) srcNode.getData(), initializer);
   }
Index: component/core/src/main/java/org/exoplatform/services/jcr/impl/xml/importing/BaseXmlImporter.java
===================================================================
--- component/core/src/main/java/org/exoplatform/services/jcr/impl/xml/importing/BaseXmlImporter.java	(revision 68057)
+++ component/core/src/main/java/org/exoplatform/services/jcr/impl/xml/importing/BaseXmlImporter.java	(working copy)
@@ -185,7 +185,8 @@
                                         itemState.isEventFire(),
                                         ancestorToSave,
                                         itemState.isInternallyCreated(),
-                                        itemState.isPersisted()));
+                                        itemState.isPersisted(),
+                                        itemState.getOldPath()));
       }
       changesLog.clear();
       changesLog.addAll(newChangesLog.getAllStates());
Index: component/core/src/main/java/org/exoplatform/services/jcr/impl/dataflow/ItemDataMoveVisitor.java
===================================================================
--- component/core/src/main/java/org/exoplatform/services/jcr/impl/dataflow/ItemDataMoveVisitor.java	(revision 68057)
+++ component/core/src/main/java/org/exoplatform/services/jcr/impl/dataflow/ItemDataMoveVisitor.java	(working copy)
@@ -71,6 +71,11 @@
   protected boolean             keepIdentifiers;
 
   /**
+   * Trigger events for descendents.
+   */
+  protected boolean             triggerEventsForDescendents;
+
+  /**
    * The NodeTypeManager
    */
   protected NodeTypeManagerImpl ntManager;
@@ -90,22 +95,44 @@
    *          - Source data manager
    * @param keepIdentifiers
    *          - Is it necessity to keep <code>Identifiers</code>
+   * @param triggerEventsForDescendents
+   *          - Trigger events for descendents.         
    */
-
   public ItemDataMoveVisitor(NodeData parent,
                              InternalQName dstNodeName,
                              NodeTypeManagerImpl nodeTypeManager,
                              SessionDataManager srcDataManager,
-                             boolean keepIdentifiers) {
-    super(srcDataManager);
+                             boolean keepIdentifiers,
+                             boolean triggerEventsForDescendents) {
+    super(srcDataManager, triggerEventsForDescendents ? INFINITE_DEPTH : 0);
     this.keepIdentifiers = keepIdentifiers;
     this.ntManager = nodeTypeManager;
     this.destNodeName = dstNodeName;
 
     this.parents = new Stack<NodeData>();
     this.parents.add(parent);
+    this.triggerEventsForDescendents = triggerEventsForDescendents;
   }
 
+  /**
+   * Creates an instance of this class.
+   * 
+   * @param parent - The parent node
+   * @param dstNodeName Destination node name
+   * @param nodeTypeManager - The NodeTypeManager
+   * @param srcDataManager - Source data manager
+   * @param keepIdentifiers - Is it necessity to keep <code>Identifiers</code>
+   * @param triggerEventsForDescendents - Don't generate events for the
+   *          descendants.
+   */
+  public ItemDataMoveVisitor(NodeData parent,
+                             InternalQName dstNodeName,
+                             NodeTypeManagerImpl nodeTypeManager,
+                             SessionDataManager srcDataManager,
+                             boolean keepIdentifiers) {
+    this(parent, dstNodeName, nodeTypeManager, srcDataManager, keepIdentifiers, false);
+  }
+
   @Override
   protected void entering(NodeData node, int level) throws RepositoryException {
 
@@ -210,13 +237,23 @@
     parents.push(newNode);
 
     // ancestorToSave is a parent node
-    // if level == 0 set internal createt as false for validating on save
+    // if level == 0 set internal create as false for validating on save
     addStates.add(new ItemState(newNode,
                                 ItemState.RENAMED,
                                 level == 0,
                                 ancestorToSave,
                                 false,
                                 level == 0));
+    if (!triggerEventsForDescendents) {
+      addStates.add(new ItemState(newNode,
+                                  ItemState.PATH_CHANGED,
+                                  false,
+                                  ancestorToSave,
+                                  false,
+                                  false,
+                                  node.getQPath()));
+    }
+
     deleteStates.add(new ItemState(node,
                                    ItemState.DELETED,
                                    level == 0,
Index: component/core/src/main/java/org/exoplatform/services/jcr/impl/dataflow/session/LocalWorkspaceStorageDataManagerProxy.java
===================================================================
--- component/core/src/main/java/org/exoplatform/services/jcr/impl/dataflow/session/LocalWorkspaceStorageDataManagerProxy.java	(revision 68057)
+++ component/core/src/main/java/org/exoplatform/services/jcr/impl/dataflow/session/LocalWorkspaceStorageDataManagerProxy.java	(working copy)
@@ -90,7 +90,8 @@
                                  change.isEventFire(),
                                  change.getAncestorToSave(),
                                  change.isInternallyCreated(),
-                                 change.isPersisted()));
+                                 change.isPersisted(),
+                                 change.getOldPath()));
       }
 
       newLog.addLog(new PlainChangesLogImpl(states, changes.getSessionId(), changes.getEventType()));
Index: component/core/src/main/java/org/exoplatform/services/jcr/impl/dataflow/persistent/LinkedWorkspaceStorageCacheImpl.java
===================================================================
--- component/core/src/main/java/org/exoplatform/services/jcr/impl/dataflow/persistent/LinkedWorkspaceStorageCacheImpl.java	(revision 68057)
+++ component/core/src/main/java/org/exoplatform/services/jcr/impl/dataflow/persistent/LinkedWorkspaceStorageCacheImpl.java	(working copy)
@@ -44,6 +44,8 @@
 import org.exoplatform.services.jcr.datamodel.QPath;
 import org.exoplatform.services.jcr.datamodel.QPathEntry;
 import org.exoplatform.services.jcr.impl.Constants;
+import org.exoplatform.services.jcr.impl.dataflow.TransientNodeData;
+import org.exoplatform.services.jcr.impl.dataflow.TransientPropertyData;
 import org.exoplatform.services.log.ExoLogger;
 
 /**
@@ -1548,6 +1550,65 @@
           // MOVE operation (DESTENATION changes, same as ADDED), states for whole subtree!
           // RENAME goes before DELETE
           put(item);
+        } else if (state.isPathChanged()) {
+
+          writeLock.lock();
+          try {
+            for (Entry<CacheKey, CacheValue> cacheEntry : cache.entrySet()) {
+              CacheKey cacheKey = cacheEntry.getKey();
+              CacheValue cacheValue = cacheEntry.getValue();
+
+              
+              ItemData oldItemData = cacheValue.getItem();
+              if (oldItemData.getQPath().isDescendantOf(state.getOldPath())) {
+                int relativeDegree = oldItemData.getQPath().getDepth()
+                    - state.getOldPath().getDepth();
+
+                QPath newQPath = QPath.makeChildPath(state.getData().getQPath(),
+                                                     oldItemData.getQPath()
+                                                                .getRelPath(relativeDegree));
+
+                if (oldItemData.isNode()) {
+                  NodeData nodeData = (NodeData) oldItemData;
+                  TransientNodeData newItemData = new TransientNodeData(newQPath,
+                                                               nodeData.getIdentifier(),
+                                                               nodeData.getPersistedVersion(),
+                                                               nodeData.getPrimaryTypeName(),
+                                                               nodeData.getMixinTypeNames(),
+                                                               nodeData.getOrderNumber(),
+                                                               nodeData.getParentIdentifier(),
+                                                               nodeData.getACL());
+                  cache.put(cacheKey, new CacheValue(newItemData, cacheValue.getExpiredTime()));
+
+                  // update in children nodes
+                  List<NodeData> cachedChildNodes = nodesCache.get(nodeData.getParentIdentifier());
+                  if (cachedChildNodes != null) {
+                    int index = cachedChildNodes.indexOf(oldItemData);
+                    cachedChildNodes.set(index, newItemData);
+                  }
+                } else {
+                  PropertyData oldPropertyData = (PropertyData) oldItemData;
+                  TransientPropertyData newPropertyData = new TransientPropertyData(newQPath,
+                                                                                    oldPropertyData.getIdentifier(),
+                                                                                    oldPropertyData.getPersistedVersion(),
+                                                                                    oldPropertyData.getType(),
+                                                                                    oldPropertyData.getParentIdentifier(),
+                                                                                    oldPropertyData.isMultiValued());
+                  newPropertyData.setValues(oldPropertyData.getValues());
+                  cache.put(cacheKey, new CacheValue(newPropertyData, cacheValue.getExpiredTime()));
+
+                  // update in children properties
+                  List<PropertyData> cachedChildProps = propertiesCache.get(oldPropertyData.getParentIdentifier());
+                  if (cachedChildProps != null) {
+                    int index = cachedChildProps.indexOf(oldItemData);
+                    cachedChildProps.set(index, newPropertyData);
+                  }
+                }
+              }
+            }
+          } finally {
+            writeLock.unlock();
+          }
         } else if (state.isUpdated()) {
           // UPDATE occurs on reordered (no subtree!) and merged nodes (for each merged-updated)
           if (item.isNode()) {
Index: component/core/src/main/java/org/exoplatform/services/jcr/storage/WorkspaceDataContainer.java
===================================================================
--- component/core/src/main/java/org/exoplatform/services/jcr/storage/WorkspaceDataContainer.java	(revision 68057)
+++ component/core/src/main/java/org/exoplatform/services/jcr/storage/WorkspaceDataContainer.java	(working copy)
@@ -33,7 +33,10 @@
 public interface WorkspaceDataContainer extends DataContainer {
 
   // configuration params
+  public static final String  TRIGGER_EVENTS_FOR_DESCENDENTS_ON_RENAME         = "trigger-events-for-descendents-on-rename";
 
+  public static final boolean TRIGGER_EVENTS_FOR_DESCENDENTS_ON_RENAME_DEFAULT = true;
+
   public final static String CONTAINER_NAME    = "containerName";
 
   public final static String SOURCE_NAME       = "source-name";
