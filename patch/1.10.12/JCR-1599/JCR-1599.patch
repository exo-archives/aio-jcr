Index: component/core/src/main/java/org/exoplatform/services/jcr/dataflow/ItemState.java
===================================================================
--- component/core/src/main/java/org/exoplatform/services/jcr/dataflow/ItemState.java	(revision 68057)
+++ component/core/src/main/java/org/exoplatform/services/jcr/dataflow/ItemState.java	(working copy)
@@ -51,6 +51,8 @@
 
   public static final int     RENAMED           = 32;
 
+  public static final int     PATH_CHANGED      = 64;
+
   /**
    * underlying item data
    */
@@ -66,7 +68,7 @@
   private transient boolean   internallyCreated = false;
 
   /**
-   * if storing of this state ahould cause event firing
+   * if storing of this state should cause event firing
    */
   protected transient boolean eventFire;
 
@@ -76,15 +78,18 @@
   private transient QPath     ancestorToSave;
 
   /**
+   * Storing old node path during Session.move() operation
+   */
+  private transient QPath     oldPath;
+
+  /**
    * The constructor
    * 
-   * @param data
-   *          underlying data
+   * @param data underlying data
    * @param state
-   * @param eventFire
-   *          - if the state cause some event firing
-   * @param ancestorToSave
-   *          - path of item which should be called in save (usually for session.move())
+   * @param eventFire - if the state cause some event firing
+   * @param ancestorToSave - path of item which should be called in save
+   *          (usually for session.move())
    */
   public ItemState(ItemData data, int state, boolean eventFire, QPath ancestorToSave) {
     this(data, state, eventFire, ancestorToSave, false, true);
@@ -131,6 +136,17 @@
 
   }
 
+  public ItemState(ItemData data,
+                   int state,
+                   boolean eventFire,
+                   QPath ancestorToSave,
+                   boolean isInternalCreated,
+                   boolean isPersisted,
+                   QPath oldPath) {
+    this(data, state, eventFire, ancestorToSave, isInternalCreated, isPersisted);
+    this.oldPath = oldPath;
+  }
+
   public boolean isPersisted() {
     return isPersisted;
   }
@@ -177,6 +193,10 @@
     return (state == RENAMED);
   }
 
+  public boolean isPathChanged() {
+    return (state == PATH_CHANGED);
+  }
+
   public boolean isEventFire() {
     return eventFire;
   }
@@ -197,6 +217,11 @@
     return ancestorToSave;
   }
 
+  public QPath getOldPath() {
+    return oldPath;
+  }
+
+  @Override
   public boolean equals(Object obj) {
     if (this == obj)
       return true;
@@ -298,6 +323,8 @@
       return "MIXIN_CHANGED";
     case RENAMED:
       return "RENAMED";
+    case PATH_CHANGED:
+      return "PATH_CHANGED";
     default:
       return "UNDEFINED STATE";
     }
Index: component/core/src/main/java/org/exoplatform/services/jcr/impl/core/SessionImpl.java
===================================================================
--- component/core/src/main/java/org/exoplatform/services/jcr/impl/core/SessionImpl.java	(revision 68057)
+++ component/core/src/main/java/org/exoplatform/services/jcr/impl/core/SessionImpl.java	(working copy)
@@ -95,6 +95,8 @@
  */
 public class SessionImpl implements ExtendedSession, NamespaceAccessor {
 
+  public static final String                   SKIP_EVENTS_FOR_DESCENDENTS_ON_RENAME = "skip-events-for-descendents-on-rename";
+  
   private final RepositoryImpl                 repository;
 
   private final ConversationState              userState;
@@ -131,6 +133,8 @@
 
   private long                                 lastAccessTime;
 
+  private boolean                              skipEventsForDescendentsOnRename;
+
   private final SessionRegistry                sessionRegistry;
 
   protected final SessionDataManager           dataManager;
@@ -178,7 +182,9 @@
 
     sessionRegistry.registerSession(this);
     this.lastAccessTime = System.currentTimeMillis();
-
+    this.skipEventsForDescendentsOnRename = wsConfig.getContainer()
+                                                    .getParameterBoolean(SKIP_EVENTS_FOR_DESCENDENTS_ON_RENAME,
+                                                                         false);
   }
 
   /*
@@ -705,7 +711,7 @@
                                                                              .getMemberships(),
                                                                     userState.getIdentity()
                                                                              .getRoles()));
-    return (Session) sessionFactory.createSession(newState);
+    return sessionFactory.createSession(newState);
 
   }
 
@@ -871,7 +877,10 @@
                                                                           .getInternalName(),
                                                               getWorkspace().getNodeTypeManager(),
                                                               getTransientNodesManager(),
-                                                              true);
+                                                              true,
+                                                              skipEventsForDescendentsOnRename
+                                                                  && srcNodePath.makeParentPath()
+                                                                         .equals(destNodePath.makeParentPath()));
 
     getTransientNodesManager().rename((NodeData) srcNode.getData(), initializer);
   }
Index: component/core/src/main/java/org/exoplatform/services/jcr/impl/dataflow/ItemDataMoveVisitor.java
===================================================================
--- component/core/src/main/java/org/exoplatform/services/jcr/impl/dataflow/ItemDataMoveVisitor.java	(revision 68057)
+++ component/core/src/main/java/org/exoplatform/services/jcr/impl/dataflow/ItemDataMoveVisitor.java	(working copy)
@@ -71,6 +71,11 @@
   protected boolean             keepIdentifiers;
 
   /**
+   * Don't generate events for the descendants.
+   */
+  protected boolean             skipEventsForDescendents;
+
+  /**
    * The NodeTypeManager
    */
   protected NodeTypeManagerImpl ntManager;
@@ -90,22 +95,44 @@
    *          - Source data manager
    * @param keepIdentifiers
    *          - Is it necessity to keep <code>Identifiers</code>
+   * @param skipEventsForDescendents
+   *          - Don't generate events for the descendants.         
    */
-
   public ItemDataMoveVisitor(NodeData parent,
                              InternalQName dstNodeName,
                              NodeTypeManagerImpl nodeTypeManager,
                              SessionDataManager srcDataManager,
-                             boolean keepIdentifiers) {
-    super(srcDataManager);
+                             boolean keepIdentifiers,
+                             boolean skipEventsForDescendents) {
+    super(srcDataManager, skipEventsForDescendents ? 0 : -1);
     this.keepIdentifiers = keepIdentifiers;
     this.ntManager = nodeTypeManager;
     this.destNodeName = dstNodeName;
 
     this.parents = new Stack<NodeData>();
     this.parents.add(parent);
+    this.skipEventsForDescendents = skipEventsForDescendents;
   }
 
+  /**
+   * Creates an instance of this class.
+   * 
+   * @param parent - The parent node
+   * @param dstNodeName Destination node name
+   * @param nodeTypeManager - The NodeTypeManager
+   * @param srcDataManager - Source data manager
+   * @param keepIdentifiers - Is it necessity to keep <code>Identifiers</code>
+   * @param skipEventsForDescendents - Don't generate events for the
+   *          descendants.
+   */
+  public ItemDataMoveVisitor(NodeData parent,
+                             InternalQName dstNodeName,
+                             NodeTypeManagerImpl nodeTypeManager,
+                             SessionDataManager srcDataManager,
+                             boolean keepIdentifiers) {
+    this(parent, dstNodeName, nodeTypeManager, srcDataManager, keepIdentifiers, false);
+  }
+
   @Override
   protected void entering(NodeData node, int level) throws RepositoryException {
 
@@ -210,13 +237,23 @@
     parents.push(newNode);
 
     // ancestorToSave is a parent node
-    // if level == 0 set internal createt as false for validating on save
+    // if level == 0 set internal create as false for validating on save
     addStates.add(new ItemState(newNode,
                                 ItemState.RENAMED,
                                 level == 0,
                                 ancestorToSave,
                                 false,
                                 level == 0));
+    if (skipEventsForDescendents) {
+      addStates.add(new ItemState(newNode,
+                                  ItemState.PATH_CHANGED,
+                                  false,
+                                  ancestorToSave,
+                                  false,
+                                  false,
+                                  node.getQPath()));
+    }
+
     deleteStates.add(new ItemState(node,
                                    ItemState.DELETED,
                                    level == 0,
Index: component/core/src/main/java/org/exoplatform/services/jcr/impl/dataflow/session/LocalWorkspaceStorageDataManagerProxy.java
===================================================================
--- component/core/src/main/java/org/exoplatform/services/jcr/impl/dataflow/session/LocalWorkspaceStorageDataManagerProxy.java	(revision 68057)
+++ component/core/src/main/java/org/exoplatform/services/jcr/impl/dataflow/session/LocalWorkspaceStorageDataManagerProxy.java	(working copy)
@@ -90,7 +90,8 @@
                                  change.isEventFire(),
                                  change.getAncestorToSave(),
                                  change.isInternallyCreated(),
-                                 change.isPersisted()));
+                                 change.isPersisted(),
+                                 change.getOldPath()));
       }
 
       newLog.addLog(new PlainChangesLogImpl(states, changes.getSessionId(), changes.getEventType()));
Index: component/core/src/main/java/org/exoplatform/services/jcr/impl/dataflow/persistent/LinkedWorkspaceStorageCacheImpl.java
===================================================================
--- component/core/src/main/java/org/exoplatform/services/jcr/impl/dataflow/persistent/LinkedWorkspaceStorageCacheImpl.java	(revision 68057)
+++ component/core/src/main/java/org/exoplatform/services/jcr/impl/dataflow/persistent/LinkedWorkspaceStorageCacheImpl.java	(working copy)
@@ -44,6 +44,8 @@
 import org.exoplatform.services.jcr.datamodel.QPath;
 import org.exoplatform.services.jcr.datamodel.QPathEntry;
 import org.exoplatform.services.jcr.impl.Constants;
+import org.exoplatform.services.jcr.impl.dataflow.TransientNodeData;
+import org.exoplatform.services.jcr.impl.dataflow.TransientPropertyData;
 import org.exoplatform.services.log.ExoLogger;
 
 /**
@@ -1548,6 +1550,64 @@
           // MOVE operation (DESTENATION changes, same as ADDED), states for whole subtree!
           // RENAME goes before DELETE
           put(item);
+        } else if (state.isPathChanged()) {
+
+          writeLock.lock();
+          try {
+            for (Entry<CacheKey, CacheValue> cacheEntry : cache.entrySet()) {
+              CacheKey cacheKey = cacheEntry.getKey();
+              CacheValue cacheValue = cacheEntry.getValue();
+
+              
+              ItemData oldItemData = cacheValue.getItem();
+              if (oldItemData.getQPath().isDescendantOf(state.getOldPath())) {
+                int relativeDegree = oldItemData.getQPath().getEntries().length
+                    - state.getData().getQPath().getEntries().length;
+                QPath newQPath = QPath.makeChildPath(state.getData().getQPath(),
+                                                     oldItemData.getQPath()
+                                                                .getRelPath(relativeDegree));
+
+                if (oldItemData.isNode()) {
+                  NodeData nodeData = (NodeData) oldItemData;
+                  TransientNodeData newItemData = new TransientNodeData(newQPath,
+                                                               nodeData.getIdentifier(),
+                                                               nodeData.getPersistedVersion(),
+                                                               nodeData.getPrimaryTypeName(),
+                                                               nodeData.getMixinTypeNames(),
+                                                               nodeData.getOrderNumber(),
+                                                               nodeData.getParentIdentifier(),
+                                                               nodeData.getACL());
+                  cache.put(cacheKey, new CacheValue(newItemData, cacheValue.getExpiredTime()));
+
+                  // update in children nodes
+                  List<NodeData> cachedChildNodes = nodesCache.get(nodeData.getParentIdentifier());
+                  if (cachedChildNodes != null) {
+                    int index = cachedChildNodes.indexOf(oldItemData);
+                    cachedChildNodes.set(index, newItemData);
+                  }
+                } else {
+                  PropertyData oldPropertyData = (PropertyData) oldItemData;
+                  TransientPropertyData newPropertyData = new TransientPropertyData(newQPath,
+                                                                                    oldPropertyData.getIdentifier(),
+                                                                                    oldPropertyData.getPersistedVersion(),
+                                                                                    oldPropertyData.getType(),
+                                                                                    oldPropertyData.getParentIdentifier(),
+                                                                                    oldPropertyData.isMultiValued());
+                  newPropertyData.setValues(oldPropertyData.getValues());
+                  cache.put(cacheKey, new CacheValue(newPropertyData, cacheValue.getExpiredTime()));
+
+                  // update in children properties
+                  List<PropertyData> cachedChildProps = propertiesCache.get(oldPropertyData.getParentIdentifier());
+                  if (cachedChildProps != null) {
+                    int index = cachedChildProps.indexOf(oldItemData);
+                    cachedChildProps.set(index, newPropertyData);
+                  }
+                }
+              }
+            }
+          } finally {
+            writeLock.unlock();
+          }
         } else if (state.isUpdated()) {
           // UPDATE occurs on reordered (no subtree!) and merged nodes (for each merged-updated)
           if (item.isNode()) {
