                             ----------
                             JCR LOCKS IMPLEMENTATION Specification
                             ----------

JCR LOCKS IMPLEMENTATION Specification

* Introduction

   The main purpose of locking is a creation of mechanism which allows a user
   to temporarily lock nodes in order to prevent other users from changing them.
  
* The basic use cases are: 

   [[1]] Placing a lock

      [[a]] Node.lock(boolean isDeep, boolean isSessionScoped)   JCR 1.0 API

      [[b]] Node.lock(boolean isDeep, long timeOut)         eXo JCR's ExtendedNode interface

   [[2]]   remove lock

      [[a]] Node.unlock() 

      [[b]] Removing of locking node by any user with sufficient access permissions as long as its parent node is not locked. 

      [[c]] By time out.

      [[d]] Removal sessionScoped  locking on closing session during which locking has been created.

      [[e]] If Content Repository turn off, or turn on after crash.

   [[3]]   Check of locking during operations of writing.

      [[a]] Node.isLocked()

   [[4]]   Reading information about locks and to serve lock tokens(API).

      [[a]]Node.getLock().

      [[b]]Node.holdsLock().

      [[c]]Node.holdsLock().

      [[d]]Session.addLockToken(String token).

      [[e]]Session.getLockTokens().

      [[f]]Session.removeLockToken().
   
* The user activity scheme: 
   
[images/lock.jpg]
   
   
* IMPLEMENTATION objects


**   LockManager implements Startable, ItemsPersistenceListener, SessionLifecycleListener

   [[1]]   Lock getLock(NodeImpl).

      [[a]]   Tries to find lockData of node or lockData of her nearest parent.

         [[1]]   If such object is not present it means what node is not locked and LockException has been throw.

         [[1]]    If locking of the parent is found and it not deep, it means what node is not locked and LockException has been throw.

      [[b]]    If all conditions are satisfied return new LockImpl using LockData which we have found.

   [[2]]   boolean isLocked(NodeData data,Session Id).

      [[a]]   Tries to find in the list of locking corresponding LockData if such data is not present or we not have deep locking of parent it means what node is not locked.

   [[3]]   boolean isLockHolder(NodeImpl).

      [[a]]   Checks whether the current session is in the list of lock holders of the lock of the given node.

   [[4]]   boolean holdsLock(NodeData node).

      [[a]]   We search for locking for current nodde, if such exists, it means the node holds the lock.

   [[5]]   void addPendingLock(NodeImpl, isDeep, boolean isSessionScoped, long timeOut).

      [[a]]   Checks, whether to be current node in locking or whether its parent is locked by deep lock.

      [[b]]   Checks, if it is necessary to add deep locking, whether to be the child node not in the list of locking.

      [[c]]   If all conditions are satisfied adds a new lock in the list of locking.

   [[6]]   onSaveItems().

      [[a]]   If there is a changesLog of type ExtendedEvent.LOCK, we add a new lock to the list of locks.

      [[b]]   If there is a changesLog of type ExtendedEvent.UNLOCK, we remove a lock from the list of locks.

      [[c]]   If there is a changesLog of undefined type, and we find a change which correspond to the locked node and If in the list after unlocking, there is a locking on this node with the same UUID, we make a conclusion that this is moving and do nothing. If locking further in the list is not present, we simply delete locking.

   [[7]]   onCloseSession(SessionImpl session).

      [[a]]   Passes through the all alive locking at which session is the holder.

         [[1]]   If it not SessionScoped locking, we delete session from the list lock holders.

         [[2]]   If it SessionScoped locking we checked, if no more lock holders in the lock then we make a unlocking of the node.

      [[a]]   We delete not alive locking.

   [[8]]   String[] getLockTokens(String sessionID).

      [[a]]   Passes through the list of locks and collects all accessible to the session lockTokens.

   [[9]]   addLockToken(String sessionId, String lt).

      [[a]]   Finding lockData witch corresponds to the lockToke and add session to the list of lock holders.

   [[10]]   removeLockToken (String sessionId, String lt).

      [[a]]   Finding lockData witch corresponds to the lockToke and add remove session from the list of lock holders.

   [[11]]   removeLock(String sessionId, String nodeUuid).

      [[a]]   Checks whether really given node it is locked also the parent of this node it is not locked.

      [[b]]   Deletes locking from the list of locking.Set live of LockData to false.
   
**   LockImpl object implements Lock  and contains fields

   [[1]]   LockData data.

   [[2]]   SessionImpl session.

**   LockData object
   
   [[1]]   contains fields 

      [[a]]   boolean deep.

      [[b]]   boolean sessionScoped.

      [[c]]   String lockToken.

      [[d]]   String owner - The user who places a lock on a node.

      [[e]]   String nodeUuid - The uuid of the node on which lock has been created.

      [[f]]   birthday - The time when the lock has been created.

      [[g]]   timeOut.

      [[h]]   Set lockHolders.

   [[2]]    Methods
      [[a]]   getLockToken(String sessionId)  - Returns lockToken if sessionId is the holder of locking differently return null.

      [[b]]   addLockHolder(String sessionId)  - Adds sessionId  to the lis lockHolder.

      [[c]]   removeLockHolder(String sessionId) – Removes sessionId  from the list of lock holders.

      [[d]]   isLockHolder(String sessionId)  - Determines  whether is session the holder of locking.

      [[e]]   getLockHolderSize() - Returns amount of sessions, holders of locking.

      [[f]]   getTimeToDeath() - Returns time in seconds before automatic removal of locking.

      [[g]]   Refresh() - Increases time of a life of locking on timeOut seconds.
    